// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreateCommitsParams struct {
	Sha          string    `json:"sha"`
	RepositoryID int64     `json:"repository_id"`
	AuthorName   string    `json:"author_name"`
	AuthorEmail  string    `json:"author_email"`
	Message      string    `json:"message"`
	Url          string    `json:"url"`
	CommitDate   time.Time `json:"commit_date"`
}

const createRepository = `-- name: CreateRepository :one
INSERT INTO repositories (
    github_repo_id, owner, name, description, url, language,
    forks_count, stars_count, open_issues_count, watchers_count,
    repo_created_at, repo_updated_at
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
         )
    RETURNING id, github_repo_id, owner, name, description, url, language, forks_count, stars_count, open_issues_count, watchers_count, repo_created_at, repo_updated_at, last_synced_at, created_at, updated_at
`

type CreateRepositoryParams struct {
	GithubRepoID    int64     `json:"github_repo_id"`
	Owner           string    `json:"owner"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	Url             string    `json:"url"`
	Language        string    `json:"language"`
	ForksCount      int32     `json:"forks_count"`
	StarsCount      int32     `json:"stars_count"`
	OpenIssuesCount int32     `json:"open_issues_count"`
	WatchersCount   int32     `json:"watchers_count"`
	RepoCreatedAt   time.Time `json:"repo_created_at"`
	RepoUpdatedAt   time.Time `json:"repo_updated_at"`
}

func (q *Queries) CreateRepository(ctx context.Context, arg CreateRepositoryParams) (Repository, error) {
	row := q.db.QueryRow(ctx, createRepository,
		arg.GithubRepoID,
		arg.Owner,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Language,
		arg.ForksCount,
		arg.StarsCount,
		arg.OpenIssuesCount,
		arg.WatchersCount,
		arg.RepoCreatedAt,
		arg.RepoUpdatedAt,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.GithubRepoID,
		&i.Owner,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Language,
		&i.ForksCount,
		&i.StarsCount,
		&i.OpenIssuesCount,
		&i.WatchersCount,
		&i.RepoCreatedAt,
		&i.RepoUpdatedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommitsByRepoID = `-- name: GetCommitsByRepoID :many
SELECT sha, repository_id, author_name, author_email, message, url, commit_date, created_at FROM commits
WHERE repository_id = $1
ORDER BY commit_date DESC
`

func (q *Queries) GetCommitsByRepoID(ctx context.Context, repositoryID int64) ([]Commit, error) {
	rows, err := q.db.Query(ctx, getCommitsByRepoID, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Commit
	for rows.Next() {
		var i Commit
		if err := rows.Scan(
			&i.Sha,
			&i.RepositoryID,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.Message,
			&i.Url,
			&i.CommitDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCommitDateForRepo = `-- name: GetLatestCommitDateForRepo :one
SELECT MAX(commit_date)::timestamp AS max_date FROM commits
WHERE repository_id = $1
`

func (q *Queries) GetLatestCommitDateForRepo(ctx context.Context, repositoryID int64) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getLatestCommitDateForRepo, repositoryID)
	var max_date pgtype.Timestamp
	err := row.Scan(&max_date)
	return max_date, err
}

const getRepositoryByOwnerAndName = `-- name: GetRepositoryByOwnerAndName :one

SELECT id, github_repo_id, owner, name, description, url, language, forks_count, stars_count, open_issues_count, watchers_count, repo_created_at, repo_updated_at, last_synced_at, created_at, updated_at FROM repositories
WHERE owner = $1 AND name = $2
LIMIT 1
`

type GetRepositoryByOwnerAndNameParams struct {
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

// internal/database/query.sql
func (q *Queries) GetRepositoryByOwnerAndName(ctx context.Context, arg GetRepositoryByOwnerAndNameParams) (Repository, error) {
	row := q.db.QueryRow(ctx, getRepositoryByOwnerAndName, arg.Owner, arg.Name)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.GithubRepoID,
		&i.Owner,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Language,
		&i.ForksCount,
		&i.StarsCount,
		&i.OpenIssuesCount,
		&i.WatchersCount,
		&i.RepoCreatedAt,
		&i.RepoUpdatedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopNCommitAuthors = `-- name: GetTopNCommitAuthors :many
SELECT
    author_name,
    author_email,
    COUNT(*) as commit_count
FROM commits
WHERE repository_id = $1
GROUP BY author_name, author_email
ORDER BY commit_count DESC
LIMIT $2
`

type GetTopNCommitAuthorsParams struct {
	RepositoryID int64 `json:"repository_id"`
	Limit        int32 `json:"limit"`
}

type GetTopNCommitAuthorsRow struct {
	AuthorName  string `json:"author_name"`
	AuthorEmail string `json:"author_email"`
	CommitCount int64  `json:"commit_count"`
}

func (q *Queries) GetTopNCommitAuthors(ctx context.Context, arg GetTopNCommitAuthorsParams) ([]GetTopNCommitAuthorsRow, error) {
	rows, err := q.db.Query(ctx, getTopNCommitAuthors, arg.RepositoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopNCommitAuthorsRow
	for rows.Next() {
		var i GetTopNCommitAuthorsRow
		if err := rows.Scan(&i.AuthorName, &i.AuthorEmail, &i.CommitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepositorySyncData = `-- name: UpdateRepositorySyncData :one
UPDATE repositories
SET
    description = $2,
    language = $3,
    forks_count = $4,
    stars_count = $5,
    open_issues_count = $6,
    watchers_count = $7,
    repo_updated_at = $8,
    last_synced_at = NOW(),
    updated_at = NOW()
WHERE id = $1
    RETURNING id, github_repo_id, owner, name, description, url, language, forks_count, stars_count, open_issues_count, watchers_count, repo_created_at, repo_updated_at, last_synced_at, created_at, updated_at
`

type UpdateRepositorySyncDataParams struct {
	ID              int64     `json:"id"`
	Description     string    `json:"description"`
	Language        string    `json:"language"`
	ForksCount      int32     `json:"forks_count"`
	StarsCount      int32     `json:"stars_count"`
	OpenIssuesCount int32     `json:"open_issues_count"`
	WatchersCount   int32     `json:"watchers_count"`
	RepoUpdatedAt   time.Time `json:"repo_updated_at"`
}

func (q *Queries) UpdateRepositorySyncData(ctx context.Context, arg UpdateRepositorySyncDataParams) (Repository, error) {
	row := q.db.QueryRow(ctx, updateRepositorySyncData,
		arg.ID,
		arg.Description,
		arg.Language,
		arg.ForksCount,
		arg.StarsCount,
		arg.OpenIssuesCount,
		arg.WatchersCount,
		arg.RepoUpdatedAt,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.GithubRepoID,
		&i.Owner,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Language,
		&i.ForksCount,
		&i.StarsCount,
		&i.OpenIssuesCount,
		&i.WatchersCount,
		&i.RepoCreatedAt,
		&i.RepoUpdatedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
